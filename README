mission
-------

Build a small Linux system with as little resource usage as possible.
Modern kernel, suckless if possible, i486 as target. Trying to
squeeze binaries with NetBSD cruch. Using a floppy boot loader
which uses a USTAR-like format for storing kernel and ramdisk.
Using musl for it's ability to produce small static binaries.

requirements
------------

- A native C compiler. gcc/clang is a must for the Linux kernel
- NASM for assembling the floppy boot loader 'uflbbl'
- a make, probably GNU make is required

directory layout
----------------

scripts/   build scripts
dowloads/  downloaded software (tarballs or git/svn/cvs checkouts)
src/       contains all unpacked sources for building
../stage0  host toolchain building
../stage1  ramdisk first native build
configs/   configurations used during building, e.g. suckless config.h files
root/      the binary artifacts of each stage
../stage0
../stage1
local/     local adaptions and configurations which go into the ramdisk
ramdisk/   the ramdisk being later compressed to ramdisk.img
tests/     test programs to test sanity of stages

patches
-------

- tcc
  * musl uses 't' and 'u' for i487 stack inline assembly, we try not
    to use floating point anywhere, currently the tcc patch is a
    non-functional stub to make musl compile
  * configure fails completly when used with the stage0 compiler, we
    patch by hand 'configure' and 'Makefile' to build a standalone
    version using stage0 libaries and header files
  * 'config.mak' sets correct pathes and CPU flags for the i386 architecure
- musl
  * tcc doesn't expand macro definitions in inline assembly:
    SYSCALL_INSNS in syscall stubs. Expanded them by hand.
  * tcc has no support for 'Complex', we just define it empty and
    we never use complex numbers
  * replaced 'weak hidden' with
    '__attribute__((weak)) __attribute__((hidden))'
    which is more standard conform
  * 'fabs', 'fmod' have assertions to not be used, they use inline
    assmmbly for i487 stack inline assembly markers
  * '*rint': fistpll to flds, tcc has not everywhere the same opcode
    mnemonics as gcc and clang
  * 'sigsetjmp': replaced 'jecxz 1f' with 'jecxz 1b' and converting the
    far forward jump to a predefied near jump
- ubase
  * 'sys/sysmacros.h' is missing for 'minor' and 'major'
- smdev
  * 'sys/sysmacros.h' is missing for 'minor' and 'major'
- netbsd-curses
  * ignoring 'strong alias' attribute
- vis
  * disabled probing of 'curses/termcap' with 'pkconfig', added them
    directly to 'configure'

dependencies
------------

- vis
  - libevent
  - libtermcap
  - netbsd-curses
  - optionally lua
- tmux
  - libevent
  - netbsd-curses (compat.h:379: error: incompatible types for redefinition of 'forkpty',
    some non-compiling fallback when there is no curses?)
- mandoc
  - zlib
  
kernel options
--------------

We just enable things we absolutely need to be running Linux, each config
option below states the main reason we think, it has to be enabled.
The starting point of the Linux kernel configuration is 'make tinyconfig'.

- CONFIG_TIMERFD
  - for sdhcp

- MODIFY_LDT_SYSCALL
  - musl
    (https://stackoverflow.com/questions/30377020/on-linux-is-tls-set-up-by-the-kernel-or-by-libc-or-other-language-runtime)
    "I haven't looked at glibc yet, but I just checked musl. It initializes
    the TLS on startup (as you said), but then also uses a set_thread_area
    syscall to make an entry in the process' LDT which points to the space
    allocated for TLS. Then libc sets the %gs register so that it refers to
    the LDT entry for TLS. (This is on x86-32 -- x86-64 uses a different
    segment register.)" – –  Alex D May 28, 2015 at 6:48

- CONFIG_UNIX (networking options), unix domain sockets
  - nscd
  - tmux
  - musl (in getpwnam)

cd ../linux

#TODO
make tinyconfig
compression ZSTD
[*] Initial RAM filesystem and RAM disk (initramfs/initrd) support
[*] XZ
[*]   Multiple users, groups and capabilities support
[*]   Posix Clocks & timers
[*]   Enable support for printk 
[*]   BUG() support
[*] Embedded system
    Processor family (486SX)
["] Enable the LDT (local descriptor table)
[*]   Legacy autoloading support
[*] Kernel support for ELF binaries
[*] Kernel support for scripts starting with #! 
[*] Enable core dump support
[*]   RAM block device support
[*]   AT keyboard (NEW)   
[*]   PS/2 mouse (NEW)
[*] Enable TTY 
[*] 8250/16550 and compatible serial support 
[*]   Console on 8250/16550 and compatible serial port
[*] Enable verbose x86 bootup info messages      
[*] Early printk   

controlling terminals: /dev/console on serial and tty0 has no tty!
https://debianforum.de/forum/viewtopic.php?t=169622&start=15
getpass in login needs legacy BSD ttys?
https://www.linuxquestions.org/questions/linux-from-scratch-13/%5Bsolved%5D-failing-to-open-dev-tty-4175685290/
https://unix.stackexchange.com/questions/170063/start-a-process-on-a-different-tty
https://omaera.org/wlog/tech/runit_init
https://pub.nethence.com/xen/guest-stali
https://forums.gentoo.org/viewtopic-t-1000292-start-0.html
#ENDTODO

bugs
----

- oksh started with executable stack
  traps: sh[1] general protection fault ip:8095780 sp:bf8b9120 error:0
  in oksh[804900+56000]
- tcc cannot compile the linux kernel. Most likely this will remain
  a bug forever.. so we must use gcc toolchain for building the kernel,
  tcc doesn't work since a long time (since tccboot) or only in non-public
  experimental tcc/linux branches
- Having i486tcc-linux self-hosting might not be feasable as we
  have too many funny build tools around and we don't want to get
  into the busybox/tinderbox trap, where everything has to be
  emulated. We rather reimplement software to use less build
  tools (at most tcc and samurai and maybe some confiure-like
  new tool).
- 'joe' is quite slow in startup. For now we resort to 'vis' with
  somewhat better performance. It's not clear whether the software is
  so slow or because we use 'tcc'.
- build only the i386 (or choosen cross-compiler), especially the native
  one for stage1. The stage0 can be a full or a partial cross-compiler
  ideally. For now both stages are building a full cross-compiler and
  then superflous architectures are removed. Fixing this likely needs
  some rewrite of the tcc Makefiles.
- The native compiler in stage1 doesn't set pathes correctly:
    # tcc -o test test.c
    tcc: error: file 'crt1.o' not found
    tcc: error: file 'crti.o' not found
    test.c:1: error: include file 'stdio.h' not found
  Does recompiling it help?
  It's just search pathes presumably still being hard-coded to root/stage1,
  this works for now (as workaround):
    i386-tcc -vv -static -L/lib -I/include -nostdlib -c  -o test.o test.c
    i386-tcc -vv -static -L/lib -I/include -nostdlib -o test /lib/crt1.o test.o /lib/libc.a
  so recompiling it inside the chroot might work (though it needs patching
  again and a stage2 probably, as it has to run inside the chroot and eventually
  even inside a qemu emulation).
- currently we bundle too many things in the initial ramdisk:
  - man pages
  - a full tcc compiler with musl/system header files and libraries
  - all kernel modules (instead of just the essential or/and the ones
    fitting to the hardware)
- kernel modules should remain uncompressed when added to the ramdisk and
  compressed as *.ko.xz when living in a normal filesystem on a floppy
  or hard disk.
- binaries are not crunched. sbase/ubase/abase create Xbase-box crunched
  binaries by hand, doesn't work across packages. NetBSD crunch approach
  could help.
- vis has no lua interpreter support build-in currently (needed?)
- gave up on ex, is not really working:
  memory management issues, always results in "Out of memory - too many lines in file"
  This editor is a little bit too low level to use anyway.
- a lot of stuff is copy-pasted between sbase/ubase/abase/smdev, etc. for
  instance parts of libutil
- we heavily use tools from the host (perl, python, make, m4, etc.) from
  the host (but we don't want those tools inside our system also). So
  self-hosting will be tricky.
- mandoc needs zlib unconditionally, if we don't have compressed man pages,
  we need to patch this and add a NO_COMPRESSION flag to 'configure.local'.
- a poweroff sending SIGUSR1 to sinit would be nice, also shutdown fails
  by leaving users logged in (stuck in shell) and it doesn't unmount /.
  (umount2 / error)
- minimal binary seed: not that important that we have a small enough requirement
  list to start with, currently:
  - host C compiler
  - host C library to link against first tcc
  - tons of tools which are not really binary seed 
    (they are just used to produce binaries)

missing things
--------------

We miss some things currently, must see where to get them from somwhere
or whether we add them to existing minimal packages (or temporarily
to abase).

- abase (we already started to add some small tools)
  - more
  - hexdump
- sbase
  - domainname (hostname exists)
- ubase
  - fdisk
- ibase (this is a hypothetical thing, internet base tools, we will
  put them into abase for now)
  - ip
  - ping
- obase:
  - chio (BSD I/O), stty
  - csh and ksh (we have oksh)
  - mt (tape management)
  - pax (archives, we have tar)
  - rcp/rsh (old, insecure)
  - systrace (as truss or strace are not really nice to build)
   => could be tricky to build, we don't want bmake too
   The comments say:
   "At least the ALIGN-macro is defined only meaningfully for x86_64."
- 9base
  - ascii
  - awk
  - bc and dc
  - diff
  - mk
  - yacc
  - troff
- others
  - byacc
  - bison

other approaches
----------------

linux-486
---------

nice ideas, preinit decompresses lzma compressed files, uses the
chromium Linux syscall wrapper to be a standalone binary (as
the C library is compressed too).

preinit/init.c
preinit/linux_syscall_support.h

no ramdisk, decompresses directly into / (which is the boot root without
an initial change_root?), so is this in RAM?

Uses buildroot for the toolchain.
Boot loader is LILO.
C-library is uclibc.
There are 486-related kernel patches, but e run without issues on 6.2 on
a real machine, so why?

I really like the shell scripts to build the system, they are extremely
simple.

gray486linux
------------

Maybe the final system is nice, but the NIX build system is not..

0001-WIP-patch-kernel-to-skip-endbr32-instruction-on-real.patch
interesting approach to ignore endbr32 without the help of fixing
gcc/binutils (we should check again, why we got it inside busybox,
musl and tinycc don't to this kind of stuff).

Use of dropbear could be a good idea.

aboriginal
----------

miniconfig.sh
hush as init shell
highly portable
lots of patches, we must see if those are still relevant
the comments in patches and comments are really funny and helpfull.
also nice autoamitzation, smoke tests using qemu and report generation

oasis
-----

statically linked, the Lua build thing is weird.
he also rewrote ninja as samurai in C (which is nice).

the package list was more or less an inspiration for our list of packages:

musl instead of glibc
sbase instead of coreutils
ubase instead of util-linux
oksh instead of bash
sdhcp instead of dhclient or dhcpcd
vis instead of vim or emacs
netbsd-curses instead of ncurses
mandoc instead of man-db

those packages we are still considering:

pigz instead of gzip
bearssl instead of openssl
byacc instead of bison
perp and sinit instead of sysvinit or systemd
netsurf instead of chromium or firefox
samurai instead of ninja
velox instead of Xorg

morpheus
--------

statically linked

stali
-----

uses suckless tools
everything statically linked

sabotage
--------

They use an old gcc without a lot of depenendencies (C++, libraries, etc.)
to build the toolchain for stage 0. This is similar to us using tcc.
This is the first distro based on musl which made musl much more suitable
to build a Linux userspace upon. Since alpine linux switched to musl,
sabotage seems to be not heavily developed anymore.

links
-----

- Other similar distributions or projects
  - Linux-i486
    - https://github.com/tcsullivan/linux-486
  - Aboriginal Linux/Mkroot/miniconfig:
    - https://github.com/landley/aboriginal
    - https://github.com/landley/mkroot
    - https://landley.net/aboriginal/documentation.html
  - Morpheus
    - https://git.2f30.org/morpheus/
  - Oasis
    - https://git.sr.ht/~mcf/oasis
  - Graylinux
    - https://github.com/marmolak/gray386linux
    - https://github.com/marmolak/gray486linux
    - https://linuxnews.de/alte-schaetzchen-linux-optimiert-fuer-386-und-486/
  - Sabotage Linux:
    - http://sabo.xyz/
    - https://sabotage-linux.neocities.org/
    - https://sabotage-linux.neocities.org/blog/11/
  - others:
    - https://www.glaucuslinux.org/
    - https://github.com/ZilchOS/bootstrap-from-tcc
    - https://github.com/oriansj
    - https://bellard.org/tcc/tccboot.html
    - https://github.com/michaelforney/
    - https://ella-0.github.io/
    - https://github.com/landley/mkroot
    - https://github.com/richfelker/musl-cross-make.git
    - https://github.com/OSPreservProject/oskit
    - https://github.com/oriansj/M2-Planet.git
    - https://github.com/MiguelVis/mescc.git
    - https://gitlab.com/janneke/mes.git
    - https://www.youtube.com/watch?v=iU0Z0vBKrtQ
      (Michael Matz, tintycc contributor, tccboot revived, tcc hacked did it on kernel 4.6, not published)
    - https://git.mills.io/prologic/ulinux
    - https://www.plop.at/en/ploplinux/downloads/full.html
    - https://git.savannah.nongnu.org/git/stage0.git
    - https://github.com/firasuke/awesome
    - https://github.com/firasuke/mussel (Firas Khalil Khana)
    - https://github.com/pikhq/bootstrap-linux
- C Compilers
  - https://repo.or.cz/w/tinycc.git
- C Libraries
  - https://www.fefe.de/dietlibc
    (https://www.monperrus.net/martin/compiling-tcc-with-dietlibc: sadly
    has issues and was never designed to use tcc in the first place)
- tinycc and musl
  - https://wiki.musl-libc.org/design-concepts.html
  - https://www.mail-archive.com/tinycc-devel@nongnu.org/msg08533.html
  - https://lists.gnu.org/archive/html/tinycc-devel/2015-01/msg00135.html
  - https://www.mail-archive.com/tinycc-devel@nongnu.org/msg10201.html
  - https://www.mail-archive.com/tinycc-devel@nongnu.org/msg10196.html
- Terminal stuff
  - https://github.com/sabotage-linux/netbsd-curses/
  - https://www.leonerd.org.uk/code/libtermkey/
  - http://git.musl-libc.org/cgit/uuterm/tree/README
- Editors
  - https://github.com/martanne/vis
  - https://joe-editor.sourceforge.io/
  - https://ex-vi.sourceforge.net/
- Kernel
  - Tinification
    - https://weeraman.com/building-a-tiny-linux-kernel-8c07579ae79d
    - https://tiny.wiki.kernel.org/
    - http://events17.linuxfoundation.org/sites/events/files/slides/tiny.pdf
- Boot process
  - ramdisks
    - https://people.freedesktop.org/~narmstrong/meson_drm_doc/admin-guide/initrd.html
    - https://firasuke.github.io/DOTSLASHLINUX/post/booting-the-linux-kernel-without-an-initrd-initramfs/
  - device management
    - https://git.suckless.org/smdev
  - init systems
    - git://git.suckless.org/sinit
    - https://github.com/bbenne10/rc
    - https://github.com/hut/minirc
    - https://omaera.org/wlog/tech/runit_init
- minimal userland
  - https://github.com/ibara/oksh
  - git://git.suckless.org/sbase
  - git://git.suckless.org/ubase
  - https://git.andreasbaumann.cc/cgit/abase/
  - other minimal user lands (we don't use for now)
    - https://busybox.net/
    - https://landley.net/toybox/
    - https://tools.suckless.org/9base/
    - https://github.com/leahneukirchen/obase
    - https://beastiebox.sourceforge.net/
- Link collections of interesting software
  - https://suckless.org/rocks/
  - https://suckless.org/other_projects/
  - https://github.com/firasuke/awesome
  - https://wiki.musl-libc.org/alternatives.html
  - http://bashismal.blogspot.com/2011/10/unbloated-resources-in-c.html
- cruching binaries
  - https://github.com/ryao/crunch
  - http://www.bsdnewsletter.com/2003/09/Features102.html
- historical stuff
  - https://www.elinux.org/Busybox_replacement_project
