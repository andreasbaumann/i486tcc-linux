mission
-------

Build a small Linux system with as little resource usage as possible.
Modern kernel, suckless if possible, i486 as target. Trying to
squeeze binaries with NetBSD cruch. Using a floppy boot loader
which uses a USTAR-like format for storing kernel and ramdisk.
Using musl for it's ability to produce small static binaries.

requirements
------------

- A native C compiler. gcc/clang is a must for the Linux kernel
- NASM for assembling the floppy boot loader 'uflbbl'
- a make, probably GNU make is required

directory layout
----------------

scripts/   build scripts
lib/       libraries for build scripts
dowloads/  downloaded software (tarballs or git/svn/cvs checkouts)
src/       contains all unpacked sources for building
../stage0  host toolchain building
../stage1  ramdisk first native build
configs/   configurations used during building, e.g. suckless config.h files
build/     the binary artifacts of each stage
../stage0
../stage1
local/     local adaptions and configurations which go into the ramdisk
ramdisk/   the ramdisk being later compressed to ramdisk.img
root/      the root filesystem later being used via NBD or directly as image
tests/     test programs to test sanity of stages
tools/     various tools needed on the host to build the distro

patches
-------

- tcc
  * musl uses 't' and 'u' for i487 stack inline assembly, we try not
    to use floating point anywhere, currently the tcc patch is a
    non-functional stub to make musl compile
  * configure fails completly when used with the stage0 compiler, we
    patch by hand 'configure' and 'Makefile' to build a standalone
    version using stage0 libaries and header files
  * 'config.mak' sets correct pathes and CPU flags for the i386 architecure
- musl
  * tcc doesn't expand macro definitions in inline assembly:
    SYSCALL_INSNS in syscall stubs. Expanded them by hand.
  * tcc has no support for 'Complex', we just define it empty and
    we never use complex numbers
  * replaced 'weak hidden' with
    '__attribute__((weak)) __attribute__((hidden))'
    which is more standard conform
  * 'fabs', 'fmod' have assertions to not be used, they use inline
    assmmbly for i487 stack inline assembly markers
  * '*rint': fistpll to flds, tcc has not everywhere the same opcode
    mnemonics as gcc and clang
  * 'sigsetjmp': replaced 'jecxz 1f' with 'jecxz 1b' and converting the
    far forward jump to a predefied near jump
- ubase
  * 'sys/sysmacros.h' is missing for 'minor' and 'major'
- smdev
  * 'sys/sysmacros.h' is missing for 'minor' and 'major'
- netbsd-curses
  * ignoring 'strong alias' attribute
- vis
  * disabled probing of 'curses/termcap' with 'pkconfig', added them
    directly to 'configure'
- dropbear
  * patched binary locations and pathes in default_options.h

dependencies
------------

- vis
  - libevent
  - libtermcap
  - netbsd-curses
  - optionally lua
- tmux
  - libevent
  - netbsd-curses (compat.h:379: error: incompatible types for redefinition of 'forkpty',
    some non-compiling fallback when there is no curses?)
- mandoc
  - zlib
- lua51
- tinyxserver
  - tinyxlib
  - some basic fonts for default and cursor
  
kernel options
--------------

We just enable things we absolutely need to be running Linux, each config
option below states the main reason we think, it has to be enabled.
The starting point of the Linux kernel configuration is 'make tinyconfig'.

- CONFIG_M486SX=y
  - go to the lowest supported kernel "This kernel requires an i686 CPU"

- CONFIG_TTY=y
  - we need some TTY support for any kind of output

- CONFIG_VT_CONSOLE=y
  CONFIG_VGA_CONSOLE=y
  - usual VGA virtual consoles

- CONFIG_SERIAL_8250=Y
  CONFIG_SERIAL_CORE_CONSOLE=Y
  - serial console without kernel output

- CONFIG_PRINTK=y
  CONFIG_X86_VERBOSE_BOOTUP=y
  CONFIG_EARLY_PRINTK=y
  CONFIG_BUG=y
  CONFIG_DEBUG_BUGVERBOSE=y
  CONFIG_FRAME_POINTER=y
  - enable an early boot console (otherwise we don't see
    any errors anymore)
    "Booting from ROM...
    "early console in setup code"
  - show early boot messages and early console messages
  - enable bug reporting of the kernel
  - frame pointers allow stack strace in case of errors

- CONFIG_MAGIC_SYSRQ=y
  - for debugging
  
- CONFIG_LOG_BUF_SHIFT=16
  CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT=12
  - trying to make some buffers smaller, the effect might not be that
    big

- CONFIG_BLK_DEV_INITRD=y
  CONFIG_RD_XZ=y
  - allow an XZ compressed ramdisk

- CONFIG_ELF_CORE=y
  CONFIG_BINFMT_ELF=y
  - "Run /bin/sinit as init process
     Failed to execute /bin/sinit (error -2)"

- MODIFY_LDT_SYSCALL
  - "Run /bin/sinit as init process
     process '/bin/sinit' started with executable stack
     traps: sinit[1] general protection fault ip:804b0e8 sp:bfa84c10 error:0 in sinit[8049000+5000]"
     => this is the error we get
  - musl
    (https://stackoverflow.com/questions/30377020/on-linux-is-tls-set-up-by-the-kernel-or-by-libc-or-other-language-runtime)
    "I haven't looked at glibc yet, but I just checked musl. It initializes
    the TLS on startup (as you said), but then also uses a set_thread_area
    syscall to make an entry in the process' LDT which points to the space
    allocated for TLS. Then libc sets the %gs register so that it refers to
    the LDT entry for TLS. (This is on x86-32 -- x86-64 uses a different
    segment register.)" – –  Alex D May 28, 2015 at 6:48

- CONFIG_POSIX_TIMERS=y
  - "Run /bin/sinit as init process
     process '/bin/sinit' started with executable stack
     process 1 (sinit) attempted a POSIX timer syscall while CONFIG_POSIX_TIMERS is not set"

- CONFIG_BINFMT_SCRIPT=y
  - "Run /bin/sinit as init process
     ...
    "execvp: Exec format error"
    => we try to execute a shell script

- CONFIG_DEVTMPFS=y
  DEVTMPFS_MOUNT=y
  - one visible effect is that getty cannot spawn a login session (and
    on the serial console you see tons of errors about /dev/ttyX not
    being available)
  - TODO: do we still need that if we have smdev?

- CONFIG_PROC_FS=y
  - "login: ttyname: No such file or directory"

- CONFIG_MULTIUSER=y
  CONFIG_NET=y
  - "login: initgroups: Function not implemented"
  - musl (in getpwnam)
    - nscd query code which calls 'socket' and then only falls back
      to using files, this is a problem in musl.

- CONFIG_PROC_SYSCTL=y
  (CONFIG_PROC_PAGE_MONITOR=y ?)
  CONFIG_SYSFS=y
  => we want to have /proc and /sys
  => not quite sure, but either CONFIG_PROC_FS or CONFIG_SYSFS is needed)

- CONFIG_UNIX98_PTYS
  "mount: mount: devpts: No such device"

- CONFIG_COMPAT_32BIT_TIME
  - for 32-bit time parameter as in pselect (this of course made the
    whole thing non-2038-safe)
    "vis: mainloop function not implemented", needs 'pselect'

- CONFIG_MSDOS_PARTITION
  - for fdisk

- CONFIG_MODULES
  - modules support, for everything which doesn't has to be in the
    kernel, we can have a module and load it in rc.init.

- CONFIG_UNIX (networking options, as module), unix domain sockets
  - tmux

- CONFIG_PCI_QUIRKS=y
  "8139cp: 8139cp: 10/100 PCI Ethernet driver v1.3 (Mar 22, 2004)
   8139cp 0000:00:03.0: found PCI INT A -> IRQ 11
   8139cp: probe of 0000:00:03.0 failed with error -22"
  22 is EINVAL, this is a nasty one to find
  
- CONFIG_VGA_ARB
  => might be needed for PCI not to choke on VGA cards

- CONFIG_BLK_DEV_FD=m
  => we might want to use floppies for confugration or files
  
- CONFIG_BLK_DEV_NBD=m
  => NBD support for root filesystem on network block device

- CONFIG_EXT4_FS=m, CONFIG_EXT4_USE_FOR_EXT2=y
  => mount ext4 filesystems (for instance the root.img)

Debugging:

- CONFIG_KALLSYMS=y
  CONFIG_KGDB=y
  CONFIG_UNWINDER_FRAME_POINTER=y
  CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y
  CONFIG_FRAME_POINTER=y
  CONFIG_UNWINDER_FRAME_POINTER=y

Memory optimization:

- CONFIG_PHYSICAL_START=0x1000000 16M
  CONFIG_PHYSICAL_ALIGN=0x2000 8K
  CONFIG_RELOCATABLE=n
  boot.asm: set ramdisk and linux addresses correctly

tinyx/framebuffer:

- CONFIG_FB=y
  => generic framebuffer support

- CONFIG_FRAMEBUFFER_CONSOLE=y
  => console on framebuffer

- CONFIG_FRAMEBUFFER_CONSOLE_LEGACY_ACCELERATION=y
- CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y

- CONFIG_FONTS
  => do we need them, at least fk.ko complains about font functions otherwise

- CONFIG_FB_VESA=y
  => only selectable if framebuffer support is NOT built as modules
  => this also means we can only start x framebuffer X in the most generic
     SVGA case when using no modules for the framebuffer modules
  => works only if a vga=XXX parameter is passed on boot?


TODO: CONFIG_FB_VGA16=m
  => for lowest VGA mode
  => never got that one working
  => not sure if that one is needed when choosing VGA in framebuffer

TODO: looks optional for a simple running system
- CONFIG_FRAMEBUFFER_CONSOLE_LEGACY_ACCELERATION=y
  => we use fbdev low-level drivers for Cirrus, Alix, etc.

- CONFIG_FB_CIRRUS=y
  => for the Unisys 486 machine, also for qemu?

- CONFIG_FB_GEODE_LX=y
  => for the Alix 1.E

- CONFIG_MOUSE_PS2=m
- CONFIG_INPUT_MOUSEDEV=m
  CONFIG_INPUT_MOUSEDEV_PSAUX=y
  
- CONFIG_INPUT_EVDEV=m
  => /dev/input/eventX

- CONFIG_SYSFB_SIMPLEFB=y
  => so we get output after the vga= mode is set, so the output
     continues on the VGA text console
     
TODO: CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
TODO: FRAMEBUFFER_CONSOLE_DEFERRED_TAKEOVER=y
  
TODO FROM HERE:

TODO: preemption better for 1 CPU systems, Desktop?

BLOCK_LEGACY_AUTOLOAD?? needed for /dev/ram0?
are we doing pivot_root ?
  
- CONFIG_LEGACY_PTYS=y
  CONFIG_LEGACY_PTY_COUNT=16

- CONFIG_TIMERFD
  - for sdhcp

cd ../linux

#TODO
[*]   Multiple users, groups and capabilities support
[*]   Legacy autoloading support
[*] Enable core dump support
[*]   RAM block device support
[*]   AT keyboard (NEW)   
[*]   PS/2 mouse (NEW)

bugs
----

- getpass in login needs legacy BSD ttys?
- tcc cannot compile the linux kernel. Most likely this will remain
  a bug forever.. so we must use gcc toolchain for building the kernel,
  tcc doesn't work since a long time (since tccboot) or only in non-public
  experimental tcc/linux branches
- Having i486tcc-linux self-hosting might not be feasable as we
  have too many funny build tools around and we don't want to get
  into the busybox/tinderbox trap, where everything has to be
  emulated. We rather reimplement software to use less build
  tools (at most tcc and samurai and maybe some confiure-like
  new tool).
- 'joe' is quite slow in startup. For now we resort to 'vis' with
  somewhat better performance. It's not clear whether the software is
  so slow or because we use 'tcc'.
- build only the i386 (or choosen cross-compiler), especially the native
  one for stage1. The stage0 can be a full or a partial cross-compiler
  ideally. For now both stages are building a full cross-compiler and
  then superflous architectures are removed. Fixing this likely needs
  some rewrite of the tcc Makefiles.
- The native compiler in stage1 doesn't set pathes correctly:
    # tcc -o test test.c
    tcc: error: file 'crt1.o' not found
    tcc: error: file 'crti.o' not found
    test.c:1: error: include file 'stdio.h' not found
  Does recompiling it help?
  It's just search pathes presumably still being hard-coded to root/stage1,
  this works for now (as workaround):
    i386-tcc -vv -static -L/lib -I/include -nostdlib -c  -o test.o test.c
    i386-tcc -vv -static -L/lib -I/include -nostdlib -o test /lib/crt1.o test.o /lib/libc.a
  so recompiling it inside the chroot might work (though it needs patching
  again and a stage2 probably, as it has to run inside the chroot and eventually
  even inside a qemu emulation).
- currently we bundle too many things in the initial ramdisk:
  - all kernel modules (instead of just the essential or/and the ones
    fitting to the hardware)
- kernel modules should remain uncompressed when added to the ramdisk and
  compressed as *.ko.xz when living in a normal filesystem on a floppy
  or hard disk.
- binaries are not crunched. sbase/ubase/abase create Xbase-box crunched
  binaries by hand, doesn't work across packages. NetBSD crunch approach
  could help.
- vis has no lua interpreter support build-in currently (needed?)
- gave up on ex, is not really working:
  memory management issues, always results in "Out of memory - too many lines in file"
  This editor is a little bit too low level to use anyway.
- a lot of stuff is copy-pasted between sbase/ubase/abase/smdev, etc. for
  instance parts of libutil
- we heavily use tools from the host (perl, python, make, m4, etc.) from
  the host (but we don't want those tools inside our system also). So
  self-hosting will be tricky.
- mandoc needs zlib unconditionally, if we don't have compressed man pages,
  we need to patch this and add a NO_COMPRESSION flag to 'configure.local'.
- a poweroff sending SIGUSR1 to sinit would be nice, also shutdown fails
  by leaving users logged in (stuck in shell, getty is killed, but there
  is no message on the screen or so) and it doesn't unmount /.
  (umount2 / error), there is also no 'wall'
- minimal binary seed: not that important that we have a small enough requirement
  list to start with, currently:
  - host C compiler
  - host C library to link against first tcc
  - tons of tools which are not really binary seed 
    (they are just used to produce binaries)
- can we use ccache and distcc with tcc?
- nbd-client gets killed before calling killall5, we cannot mark it
  to be started by 'init' presumably (as systemd does), we can also not
  umount it otherwise we don't have killall5. There is the option of
  having a shutdown ramdisk (as others do)..
- maybe we need a shutdown ramdisk (generated on the fly or using
  pivot_root and not switch_root and reuse the init ramdisk - but
  loosing the memory while running and pivot_root is a deprecated
  syscall. And we have a new ramarchive initrd and not a traditional
  ramdisk. The shutdown ramdisk is not so much a ramdisk but a tmpfs
  you are not unmounting with the rest of the file systems. And you
  populate it with killall5 and unmount, etc.
- qemu: Slirp: Failed to send packet, ret: -1
  => seems to be a qemu network thingy..
- vis sometimes looses first line of text or shows strange artefacts
  when exiting it
- If building on x86_64, you need lib32 glibc and gcc-libs for tcc
  to link a standalone version between stage0 and stage1
- does the ramdisk get correctly unmounted? I see a /mnt busy message
  when doing the switch_root
- man pages are not compressed on the root partition, mandoc can deal
  with compressed pages (as it requires zlib)
- low memory support
  low ram: 0 - 011e0000
  -> 011E0000 = 18MB
  RAMDISK: [mem 0x00580000-0x0062bfff]
  62BFFF-580000 704511
  -> ramdisk.img is 704152 compressed, where does it get unpacked to
  Memory: 12984K/17912K available (1990K kernel code, 446K rwdata, 532K rodata, 204K init, 148K bss, 4928K reserved, 0K cma-reserved)
  -> roughly 6 MB of kernel space
  Unpacking initramfs...
  -> right, where to, or does it live in the cache only?
  Freeing initrd memory: 688K
  -> is this our ramdisk? we didn't to switch_root yet
- tcc is almost usable inside the i486 system, just some pathes are
  wrong, this small example works fine:
  mkdir -p /home/abaumann/projects/i486tcc-linux/build/stage1
  /home/abaumann/projects/i486tcc-linux/build/stage1
  ln -s /include .
  ln -s /lib .
  cat test.c <<EOF
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main( int argc, char *argv[] )
{
    puts( "hello" );
    
    exit( EXIT_SUCCESS );
}
EOF
  i386-tcc -c -o test.o test.c
  i386-tcc -static -o test test.o
  => recompilation of tcc inside the 486 system might be a problem because
     of the build system
- modern Xorg ist out of reach (and old devices DO have good framebuffer support!),
  Xvesa from tinyx doesn't build because of missin vm86 stuff (presumable for mode
  timing), this might be because we use musl?
  Xfbdev builds, vesafb only works when started at boot time (not as module) which is
  annoying.
- "Could not init font path element ../share/X11/fonts/, removing from list"
  https://www.x.org/releases/X11R7.5/doc/libXfont/fontlib.html
  => the pathes must be absolute and no errors in any file whatsover!
     Only BCF, PCF are supported
- font handling when installing, currently in local/share/fonts/X11, we
  should generate them from BCF files
- rxvt: can't load font "7x14"
- we need to set the video mode for the floppy loading mode with rdev,
  vga=? seems not to be used when booting via Linux real mode boot mode
  (qemu_direct works fine with vga=?)
- notion: keyboard XCB missing in tinyxlib? tcc: error: undefined symbol 'XkbKeycodeToKeysym'
- notion: some dummy Xrandr implementation, but as long as we don't use
  the mod_xrandr module, we should be fine (tinyxlib has some Xrandr function
  stubs for a possible extention - similar like XCB - but the implementation
  is somehow missing) 
       
tools
-----

- util-linux, version 2.17: rdev, for setting the video mode in real mode
  load mode
- bdftopcf 1.1: for converting BDF to PCF

missing things
--------------

We miss some things currently, must see where to get them from somwhere
or whether we add them to existing minimal packages (or temporarily
to abase).

- abase (we already started to add some small tools)
  - more
  - hexdump
- sbase
  - domainname (hostname exists)
- ubase
  - fdisk
  - wall
- ibase (this is a hypothetical thing, internet base tools, we will
  put them into abase for now)
  - ip
  - ping
- obase:
  - chio (BSD I/O), stty
  - csh and ksh (we have oksh)
  - mt (tape management)
  - pax (archives, we have tar)
  - rcp/rsh (old, insecure)
  - systrace (as truss or strace are not really nice to build)
   => could be tricky to build, we don't want bmake too
   The comments say:
   "At least the ALIGN-macro is defined only meaningfully for x86_64."
- 9base
  - ascii
  - awk
  - bc and dc
  - diff
  - mk
  - yacc
  - troff
- others
  - byacc
  - bison

other approaches
----------------

linux-486
---------

nice ideas, preinit decompresses lzma compressed files, uses the
chromium Linux syscall wrapper to be a standalone binary (as
the C library is compressed too).

preinit/init.c
preinit/linux_syscall_support.h

no ramdisk, decompresses directly into / (which is the boot root without
an initial change_root?), so is this in RAM?

Uses buildroot for the toolchain.
Boot loader is LILO.
C-library is uclibc.
There are 486-related kernel patches, but e run without issues on 6.2 on
a real machine, so why?

I really like the shell scripts to build the system, they are extremely
simple.

gray486linux
------------

Maybe the final system is nice, but the NIX build system is not..

0001-WIP-patch-kernel-to-skip-endbr32-instruction-on-real.patch
interesting approach to ignore endbr32 without the help of fixing
gcc/binutils (we should check again, why we got it inside busybox,
musl and tinycc don't to this kind of stuff).

Use of dropbear could be a good idea.

aboriginal
----------

miniconfig.sh
hush as init shell
highly portable
lots of patches, we must see if those are still relevant
the comments in patches and comments are really funny and helpfull.
also nice autoamitzation, smoke tests using qemu and report generation
Firmware Linux, Rob Landley, "the 7 packages to build whole of LFS on top".
The idea of making just 7 packages cross-compile and compile the rest
inside the emulation. "we cross-compile for you so you don't have to".
'mkroot' is the successor. 'toybox' is the modern variant for minimal
user land.

oasis
-----

statically linked, the Lua build thing is weird.
He also rewrote ninja as samurai in C (which is nice).
Also with QBE and cproc the user land can be built with a small C
compiler. QBE is currently lacking IA-32 support, so we can not just
rebuild oasis for our purpose (though we could write a IA-32 QBE
code generator).
The idea of using git for installation feels strange to me.
Also lua scripting for all this software introduces high maintaince costs.

the package list was more or less an inspiration for our list of packages:

musl instead of glibc
sbase instead of coreutils
ubase instead of util-linux
oksh instead of bash
sdhcp instead of dhclient or dhcpcd
vis instead of vim or emacs
netbsd-curses instead of ncurses
mandoc instead of man-db
samurai instead of ninja

those packages we are still considering:

pigz instead of gzip
bearssl instead of openssl
byacc instead of bison
perp and sinit instead of sysvinit or systemd
netsurf instead of chromium or firefox
velox instead of Xorg

morpheus
--------

statically linked
Plan 9 mk build system
x86_64 and i486 builds
quite old (kernel 3.10.32)
git://git.2f30.org/hbase (Heirloom as alernative base for some Unix tools)
textbased tools like abduco and dvtm for easy text console multiplexing
and window manager, no X
tinyalsa sounds interesting too

stali
-----

uses suckless tools
everything statically linked

sabotage
--------

They use an old gcc without a lot of depenendencies (C++, libraries, etc.)
to build the toolchain for stage 0. This is similar to us using tcc.
This is the first distro based on musl which made musl much more suitable
to build a Linux userspace upon. Since alpine linux switched to musl,
sabotage seems to be not heavily developed anymore.

links
-----

- Other similar distributions or projects
  - Linux-i486
    - https://github.com/tcsullivan/linux-486
  - Aboriginal Linux/Mkroot/miniconfig:
    - https://github.com/landley/aboriginal
    - https://github.com/landley/mkroot
    - https://landley.net/aboriginal/documentation.html
  - Morpheus
    - https://git.2f30.org/morpheus/
  - Oasis
    - https://git.sr.ht/~mcf/oasis
  - Stali
    - https://pub.nethence.com/xen/guest-stali
  - Graylinux
    - https://github.com/marmolak/gray386linux
    - https://github.com/marmolak/gray486linux
    - https://linuxnews.de/alte-schaetzchen-linux-optimiert-fuer-386-und-486/
  - Sabotage Linux:
    - http://sabo.xyz/
    - https://sabotage-linux.neocities.org/
    - https://sabotage-linux.neocities.org/blog/11/
  - others:
    - https://www.glaucuslinux.org/
    - https://github.com/ZilchOS/bootstrap-from-tcc: this is more for having
      a minimal tcc-based binary core for bootstrapping
    - https://github.com/oriansj
    - https://bellard.org/tcc/tccboot.html
    - https://github.com/michaelforney/
    - https://ella-0.github.io/
    - https://github.com/landley/mkroot
    - https://github.com/richfelker/musl-cross-make.git
    - https://github.com/OSPreservProject/oskit
    - https://github.com/oriansj/M2-Planet.git
    - https://github.com/MiguelVis/mescc.git
    - https://gitlab.com/janneke/mes.git
    - https://www.youtube.com/watch?v=iU0Z0vBKrtQ
      (Michael Matz, tintycc contributor, tccboot revived, tcc hacked did it on kernel 4.6, not published)
    - https://git.mills.io/prologic/ulinux
    - https://www.plop.at/en/ploplinux/downloads/full.html
    - https://git.savannah.nongnu.org/git/stage0.git
    - https://github.com/firasuke/awesome
    - https://github.com/firasuke/mussel (Firas Khalil Khana)
    - https://github.com/pikhq/bootstrap-linux
- C Compilers
  - https://repo.or.cz/w/tinycc.git
- C Libraries
  - https://www.fefe.de/dietlibc
    (https://www.monperrus.net/martin/compiling-tcc-with-dietlibc: sadly
    has issues and was never designed to use tcc in the first place)
- tinycc and musl
  - https://wiki.musl-libc.org/design-concepts.html
  - https://www.mail-archive.com/tinycc-devel@nongnu.org/msg08533.html
  - https://lists.gnu.org/archive/html/tinycc-devel/2015-01/msg00135.html
  - https://www.mail-archive.com/tinycc-devel@nongnu.org/msg10201.html
  - https://www.mail-archive.com/tinycc-devel@nongnu.org/msg10196.html
- Terminal stuff
  - https://github.com/sabotage-linux/netbsd-curses/
  - https://www.leonerd.org.uk/code/libtermkey/
  - http://git.musl-libc.org/cgit/uuterm/tree/README
- Editors
  - https://github.com/martanne/vis
  - https://joe-editor.sourceforge.io/
  - https://ex-vi.sourceforge.net/
- Kernel
  - Tinification
    - https://weeraman.com/building-a-tiny-linux-kernel-8c07579ae79d
    - https://tiny.wiki.kernel.org/
    - http://events17.linuxfoundation.org/sites/events/files/slides/tiny.pdf
    - https://z49x2vmq.github.io/2020/12/24/linux-tiny-qemu/
- Boot process
  - ramdisks
    - https://linuxlink.timesys.com/docs/startup_overview
    - https://people.freedesktop.org/~narmstrong/meson_drm_doc/admin-guide/initrd.html
    - https://firasuke.github.io/DOTSLASHLINUX/post/booting-the-linux-kernel-without-an-initrd-initramfs/
    - https://docs.kernel.org/admin-guide/initrd.html
    - https://landley.net/writing/rootfs-programming.html
  - device management
    - https://git.suckless.org/smdev
  - init systems
    - git://git.suckless.org/sinit
    - https://github.com/bbenne10/rc
    - https://github.com/hut/minirc
    - https://omaera.org/wlog/tech/runit_init
    - https://forums.gentoo.org/viewtopic-t-1000292-start-0.html
- minimal userland
  - https://github.com/ibara/oksh
  - suckless
    - git://git.suckless.org/sbase
    - git://git.suckless.org/ubase
  - https://git.andreasbaumann.cc/cgit/abase/
  - other minimal user lands (we don't use for now)
    - https://busybox.net/
    - https://landley.net/toybox/
    - https://tools.suckless.org/9base/
    - https://github.com/leahneukirchen/obase
    - https://beastiebox.sourceforge.net/
  - gopher://bitreich.org
  - https://git.2f30.org/hbase/log.html
- minimalism
  - https://wiki.installgentoo.com/wiki/Software_minimalism
- Link collections of interesting software
  - https://suckless.org/rocks/
  - https://suckless.org/other_projects/
  - https://github.com/firasuke/awesome
  - https://wiki.musl-libc.org/alternatives.html
  - http://bashismal.blogspot.com/2011/10/unbloated-resources-in-c.html
- cruching binaries
  - https://github.com/ryao/crunch
  - http://www.bsdnewsletter.com/2003/09/Features102.html
- TTY stuff
  - controlling terminals: /dev/console on serial and tty0 has no tty!
  - https://debianforum.de/forum/viewtopic.php?t=169622&start=15
  - https://www.linuxquestions.org/questions/linux-from-scratch-13/%5Bsolved%5D-failing-to-open-dev-tty-4175685290/
  - https://unix.stackexchange.com/questions/170063/start-a-process-on-a-different-tty
- historical stuff
  - https://www.elinux.org/Busybox_replacement_project
- qemu
  - https://en.wikibooks.org/wiki/QEMU/Devices/Network
  - https://virtuallyfun.com/2020/07/31/using-qemu-in-2020/
- nbd
  - https://patchwork.kernel.org/project/linux-block/patch_20190612163144.18486-2/roman.stratiienko@globallogic.com/
- debugging
  - https://www.kernel.org/doc/html/v4.15/dev-tools/kgdb.html
- X
  - tiny X
    - https://github.com/idunham/tinyxserver (puppy linux): has nice simple
      makefiles
    - https://github.com/tinycorelinux/tinyx, is newer, but requires autoconf mess
      to build
  - X terminal
    - xterm: bloat
    - st, requires Xft, requiring fontconfig, freetype2, etc. can eventually
      be redone to use old font library?
    - rxvt: simple and uses normal bitmap fonts (old font library)
  - X fonts
    - https://www.x.org/archive/X11R6.8.0/doc/fonts2.html
    - https://www.x.org/archive/X11R7.5/doc/man/man1/mkfontdir.1.html
    - https://www.x.org/archive//individual/font
  - X apps and stuff
    - https://www.x.org/archive/individual/app/
- terminal multiplexing
  - tmux: newer
  - screen: looks a little bit aged, might habe more features but also more code
- window manager
  - dwm/dmenu or notion3
  - notion3/notion: uses lua, loadable modules, etc. has xinerama/xrandr support,
    this is all a little bit too much
  - ion1: more suckless, maybe patchable to do what we want
    https://github.com/apenwarr/ion1

Real hardware
-------------

Unisys CDW-4002
---------------

cd lib/modules/drivers/net/ethernet/8390
insmod 8390p.ko
insmod ne.ko io=0x300 irq=10
ifconfig eth0 up
sdhcp
